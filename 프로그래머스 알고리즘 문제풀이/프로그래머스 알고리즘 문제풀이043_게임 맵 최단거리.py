# 너비우선 깊이우선 탐색
# 게임 내 최단거리를 찾아라
# 그렇다면 다수의 선택지가 주어질때 최단거리로 찾을 수 있는 방법이 있을까?
# 갈래길이 나오면 반복문을 사용해서 최단거리로 탐색하는 방법은 어떨까?

from collections import deque

def solution(maps):

    dx = [0, 0, -1, 1]
    dy = [-1, 1, 0, 0]

    # 상하좌우 [[-1,0],[1,0],[0,-1],[0,1]]
    
    
    r = len(maps)       # 행 길이
    c = len(maps[0])    # 열 길이

    graph = [[-1 for _ in range(c)] for _ in range(r)]
    
    # 그래프= 전체 행렬을 -1로 만들어놓은 지도
    
    queue = deque()
    queue.append([0, 0])
                  
    # queue 는 현재 위치

    graph[0][0] = 1
    
    #현재 위치를 1로표시 [[1,-1,-1,-1,-1],[-1,-1,-1,-1,-1]]... 인 행렬이 완성

    while queue:
        x, y = queue.popleft()
        # 현위치 지정 밑의 과정을 통해 queue에 새로운 현위치가 수정될 예정
        
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            
            # 4번의 반복문을 수행 동서남북으로 움직이게 현위치 x,y에 dx,dy 를 하나씩 추가해보고
            # 밑의 반복문 적용
            
            if 0 <= nx < r and 0 <= ny < c and maps[nx][ny] == 1:
                # x, y의 좌표가 맵을 벗어나지 않고 maps의 기준으로 이동할수 있는곳이면 아래 if문 수행
                if graph[nx][ny] == -1:
                    #그래프의 좌표가 -1이면
                    #그래프를 다 -1로 바꿔놓로 바꿔 놨으니
                    #역행은 안되지~
                    graph[nx][ny] = graph[x][y] + 1
                    #최단거리를 이전 위치+1로 해준다.
                    queue.append([nx, ny])
                    #현재 위치좌표를 queue에 넣어준다.
                    
    answer = graph[-1][-1]
    return answer

"""
이전 dfs/bfs 문제를 못 풀어서 스터디에서 이 문제를 추천했다.
bfs로 푸는 문제 였는데 결론부터 말하자면 이번에도 못풀었다.
아직도 그래프 설정이나 기본 개념들이 자리잡지 않은것 같다.
동서남북으로 방향 지정하여 맵을 벗어나지 않는 선에서 이동하는데
이동할때 몇가지 제한사항이 주어지고 그거에 맞을때 이동한다.
말로서는 표현하기 간단한데 막상 코드로 적으려면 막막한건 왜 때문일까? 
나중에 한번 더 풀어 봐야 겠다."""
