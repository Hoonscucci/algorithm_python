[1차] 비밀지도
문제 설명
비밀지도
네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.

지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 "공백"(" ") 또는 "벽"("#") 두 종류로 이루어져 있다.
전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 "지도 1"과 "지도 2"라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
"지도 1"과 "지도 2"는 각각 정수 배열로 암호화되어 있다.
암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.

네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.

입력 형식
입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.

1 ≦ n ≦ 16
arr1, arr2는 길이 n인 정수 배열로 주어진다.
정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.
출력 형식
원래의 비밀지도를 해독하여 '#', 공백으로 구성된 문자열 배열로 출력하라.

입출력 예제
매개변수	값
n	5
arr1	[9, 20, 28, 18, 11]
arr2	[30, 1, 21, 17, 28]
출력	["#####","# # #", "### #", "# ##", "#####"]
매개변수	값
n	6
arr1	[46, 33, 33 ,22, 31, 50]
arr2	[27 ,56, 19, 14, 14, 10]
출력	["######", "### #", "## ##", " #### ", " #####", "### # "]

===================================================================

def solution(n, arr1, arr2):
    answer = []
    a1 = []
    a2 = []
    a3 = []
    a4 = []
    answer = []
    for a1_1 in arr1:            
        a1_2 = bin(a1_1)[2:]   # bin함수를 사용하여 숫자르 2진법으로 바꿔주고 앞에 붙은 0b를 제거 하기위해 [2:] 를 붙여줬다.
        a1.append(a1_2)
        
    for a2_1 in arr2:
        a2_2 = bin(a2_1)[2:]   # 위와 같음
        a2.append(a2_2)
        
    for i in range(len(a1)):   # a1과 a2의 값들을 합치기 위하여 작성
        n1 = int(a1[i])        # [] 안에 문자열들을 int로 바꿔주고
        n2 = int(a2[i])        
        n_sum = n1 + n2        # 더해서 n_sum에 넣어준다
        a3.append(str(n_sum))  # str형태로 다시 a3라는 빈 list에 넣어준다.

# ex ) a1 = ["1001", "1100"] a2 = ["0011", "1111"]   a3 = ["1002", "2211"] 으로 만들었다.
    
    for a3_1 in a3:            # a3안에 있는 문자열의 길이가 주어진 n과 같아지기 위하여
        a3_2 = a3_1.zfill(n)   # n의 길이만큼 모자란 길이는 0을 채워준다
        a4.append(a3_2)        
    
    for b in a4:               # b에 list(a4)의 문자열들을 하나씩 담는다
        result = ""            # 새로운 result 라는 빈 문자열을 만들고
        for c in b:            # 한번 더 for 로 문자열 b를 하나씩 뜯어 c에 담아주고
            if c == "0":       # c가 0이면
                result += " "  # result에 공백을 추가하고
            else:              # 0이 아니면
                result += "#"  # result에 #을 추가한다
        answer.append(result)  # 2번째 for문이 끝나면 answer에 result를 append 하고 다시 처음 for로 돌아가 반복
    return answer

"""
역대급으로 문제가 길었던 문제
이해하는데도 시간이 좀 소요 되었다.
처음에 빨리 포기할까 생각도 했지만 오기가 생겨서 계속 풀게 되었다.
한줄 한줄 풀다보니 for가 많이 들어가게 되었는데 나중엔 간략하게 설명 할 수 있으면 좋겠다.
"""

=========================================================================

def solution(n, arr1, arr2):
    answer = []
    for i,j in zip(arr1,arr2):       # for 문을 사용하여 i,j에 zip함수를 사용하여 arr1과 arr2의 요소 순서대로 넣어준다.
        a12 = str(bin(i|j)[2:])      # a12에 bin(i|j[2:]) 코드를 적용한다. - bin(i|j) = ex) i = "010", j = "110" : bin(i|j) = "110" 으로 만들어 준다. - 처음 알게된 사실 
        a12=a12.rjust(n,'0')         # rjust 함수를 사용하여 오른쪽 정렬하여 n의 길이만큼 부족한 부분을 0으로 채운다.
        a12=a12.replace('1','#')     # replace로 1 = #으로 
        a12=a12.replace('0',' ')     # 0은 공백으로 바꾼다. - replace 함수를 쓰려고 노력했었지만 1,2 두개 인자를 받을때 어떻게 해야하는지와 여러 문제 등으로 구현을 못했다.
        answer.append(a12)           # 그후 answer이란 빈 list에 추가해 준다.
    return answer

"""
개인적으로 좀 충격을 받은 코드... ㅋㅋㅋ
아직 한번에 표현 할수가 없어 이런 코드를 만들 수는 없지만
첫술에 배부를 수는 없으니 하다보면 할 수 있지 않을까 싶다.
나의 6번의 for가 여기서는 1번으로 정리 되었다.
심지어 이해하기도 훨씬 쉬웠다. 
더 많은 노력이 필요 할 것 같다.
"""